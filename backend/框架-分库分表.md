##### 为什么需要分库分表？

1. 解决数据高并发的问题，（分库）
2. 解决数据量过大，查询缓慢的问题（分表）

使用分片分表的算法常见有三种

1. hash算法，或者一致性hash算法，最常见，基本都是这样的算法
2. 时间范围分片：适用老的订单查询，并且还会存在热点问题，大部分人都是查询最近一段时间的订单。
3. 人工提供分片服务，人为设置。：很少用

##### 分库分表以后会面临哪些问题？

1. 事务一致性问题，比如订单和支付记录，可能分在两个库，订单支付成功，需要写订单表 和 支付表，要保障数据全部写入成功。解决办法:

   	1.1 分布式事务 2PC

​	   1.2 最终事务一致性，某个数据失败，通过消息，日志等方式来补偿，达到最终一致性

2. 跨节点表join问题，解决方式：

​		2.1 全局配置表 可以每个库都保持同步

​		2.2 字段的冗余，但是这就需要更新的时候进行双写，比如 用户表里的昵称，和 订单表里的昵称

​        2.3 程序层面，2个表分开查，再内存里join

3. 全局主键重复问题，解决方式：

    3.1 单库 sequence 表

    3.2 redis 计数器

    3.3 分布式唯一id 雪花算法：存在时钟回拨问题，会出现重复id

    3.4 uuid

4. 跨节点的分页、计算函数、排序问题，如果是查询条件里有sharding key 其实没啥问题，遇到没有key的，最好解决方式就是 es 数仓。勉强有以下解决方式：

​	   4.1 每个分表，分别 limit ,然后合并数据 内存 重新分页

​	   4.2  业务上禁止 分页，只允许下一页，下一次查询带上上一次最大id，使用id索引 limit 速度快很多，然后再内存合并

5. 缩扩容的时候，数据迁移的问题

​		5.1 停服，新建库，然后迁移数据，再修改代码，上线，如果发现问题失败，则回滚即可

​		5.2 非停服 ，双写，双查询。

全程低峰时间

- 新建N个库，或者N个表
- 在一个低峰的时间，把某个时间点之前的数据，通过程序，或者其他工具扫全表，按照新的规则重新分配到所有库表上
- 然后时间点以后数据通过中间件订阅binlog的方式 按照新规则，再写入到全部的数据库中。
- 在整个期间，线上查询方法改造，按照旧分表规则查询，查询不到再按新规则查询，然后返回给前端，并且打印日志，记录监控。
- 在整个期间，插入方法，直接按照新规则插入，更新方法，则是按照新旧规则同时更新。
- 等待监控中显示，按照新规则100% 可以查到数据，观察一段时间后 ，切换 开关 只从新规则中查询数据。
- 人工随机 抽样数据 是否符合 key规则。

整体有个前提，需要按照shardingkey 去查询和更新插入。非shardingkey的查询还是建议 es 或者hbase 或者 数仓。



##### 分库分表中间件？

- cobar
- tddl
- atlas
- mycat
- Sharing-jdbc

##### tddl原理解析

tddl能解决的问题：

1. 单库的分库分表
2. 系统容灾，数据库宕机，提供了主备切换的能力
3. 支持切换 数据源

###### 整体架构

![CleanShot 2023-03-21 at 20.55.48@2x](/Users/jazz/Library/Application Support/CleanShot/media/media_3Vp0GahIpZ/CleanShot 2023-03-21 at 20.55.48@2x.png)

###### 逻辑结构

![CleanShot 2023-03-21 at 20.56.10@2x](/Users/jazz/Library/Application Support/CleanShot/media/media_Ja3mYu2SNO/CleanShot 2023-03-21 at 20.56.10@2x.png)

tddl在结构上分了三层，分别是 Matrix 层、Group层以及 Atom 层。

![](/Users/jazz/Library/Application Support/CleanShot/media/media_uyUdUSKcv8/CleanShot 2023-03-21 at 20.57.48@2x.png)

###### Matrix层

该层功能在于分库分表路由，SQL语句的解释、优化和执行，事务的管理规则的管理，各个子表查询出来结果集的Merge等。

Matrix 层可以解决分库分表带来的问题，从本质上来看，分库分表带来的最直接的影响是数据访问的路由。路由算法有常见几种

- 固定哈希算法
- 一致性哈希算法
- 虚拟节点
- 自定义路由规则

###### Group层

该层的作用在于数据库读写分离，基本上主数据库负责读写，备份数据库只负责读；主备切换状态对调后备库变为主库，主库变为备库；权重的选择 根据权重选择要去读哪些库；数据保护，数据库down掉后的线程保护， 数据库挂掉后的线程保护，不会因为一个数据库挂掉导致所有线程卡死。

读写分离与主备切换带来的问题是 Group 层解决的核心，当一方挂掉的时候，Group 层要马上把流量切到另一个库，保证挂掉一个不会让应用挂掉。

###### Atom层

Atom 模块真正和物理数据库交互，提供数据库配置动态修改能力。

改层负责动态创建，添加，减少数据源。管理着底层的数据库IP，连接等信息；底层对物理数据库做了代理，对单库的JDBC做了一层封装，执行底层单库的SQL；线程数、执行次数等状态的统计等。

##### 一次SQL走tddl执行流程

![CleanShot 2023-03-21 at 21.01.34@2x](/Users/jazz/Library/Application Support/CleanShot/media/media_r7YK5hVIgU/CleanShot 2023-03-21 at 21.01.34@2x.png)

TDDL的工作流程类似上图，client发送一条SQL的执行语句，会优先传递给Matrix层。由Martix 解释 SQL语句，优化，并根据查询条件路由到各个group，转发sql进行查询，各个group根据权重选择其中一个Atom进行查询，各个Atom再将结果返回给Matrix，Matrix将结果合并返回给client。具体的工作流程的可以拆分成如下图:

![](/Users/jazz/Library/Application Support/CleanShot/media/media_m0MyzKkrXC/CleanShot 2023-03-21 at 21.02.00@2x.png)

原文：https://zhuanlan.zhihu.com/p/94185797



