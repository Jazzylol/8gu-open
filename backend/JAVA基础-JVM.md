JAVA类增强简单介绍下 ？

​	![](https://pdai.tech/images/jvm/java-class-enhancer-1.png)

简单来说类增强技术就是为了可以动态的修改 java已经编译好的字节码内容。

JAVA大致分为两类字节码增强技术。

1. 静态字节码增强
2. 动态字节码增强

##### 静态字节码增强

ASM和Javassist 

asm : *ASM*是一个通用的Java字节码操作和分析框架  cglib就是基于asm的。他可以直接修改 class文件，也可以直接生产asm文件。asm应用场景是 aop，热部署，修改其他jar种的包内容。asm提供了一些利 基于字节码的api，可以直接调用api修改 字节码内容

javassist：是一个在源码级别上修改代码的  框架机制。利用Javassist实现字节码增强时，可以无须关注字节码刻板的结构，其优点就在于编程简单。直接使用java编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构或者动态生成类

- CtClass（compile-time class）：编译时类信息，它是一个class文件在代码中的抽象表现形式，可以通过一个类的全限定名来获取一个CtClass对象，用来表示这个类文件。
- ClassPool：从开发视角来看，ClassPool是一张保存CtClass信息的HashTable，key为类名，value为类名对应的CtClass对象。当我们需要对某个类进行修改时，就是通过pool.getCtClass(“className”)方法从pool中获取到相应的CtClass。
- CtMethod、CtField：这两个比较好理解，对应的是类中的方法和属性。

##### 运行时字节码修改

###### instrument

instrument是JVM提供的一个可以修改已加载类的类库，专门为Java语言编写的插桩服务提供支持。它需要依赖JVMTI的Attach API机制实现。在JDK 1.6以前，instrument只能在JVM刚启动开始加载类时生效，而在JDK 1.6之后，instrument支持了在运行时对类定义的修改。要使用instrument的类修改功能，我们需要实现它提供的ClassFileTransformer接口，定义一个类文件转换器。接口中的transform()方法会在类文件被加载时调用，而在transform方法里，我们可以利用上文中的ASM或Javassist对传入的字节码进行改写或替换，生成新的字节码数组后返回。

###### Instrumentation

在JDK 1.6之后，Instrumentation可以做启动后的Instrument、本地代码（Native Code）的Instrument，以及动态改变Classpath等等。我们可以向Instrumentation中添加上文中定义的Transformer，并指定要被重加载的类，代码如下所示。这样，当Agent被Attach到一个JVM中时，就会执行类字节码替换并重载入JVM的操作。

```JAVA
import java.lang.instrument.Instrumentation;

public class TestAgent {
    public static void agentmain(String args, Instrumentation inst) {
        //指定我们自己定义的Transformer，在其中利用Javassist做字节码替换
        inst.addTransformer(new TestTransformer(), true);
        try {
            //重定义类并载入新的字节码
            inst.retransformClasses(Base.class);
            System.out.println("Agent Load Done.");
        } catch (Exception e) {
            System.out.println("agent load failed!");
        }
    }
}
```

##### JVMTI的Attach API机制

首先要介绍jwda，Java Platform Debugger Architecture，这个是jvm的规范，要求每个jvm的实现都需要实现的一套规范。如果JVM启动时开启了JPDA，那么类是允许被重新加载的。

JPDA定义了一整套完整的体系，它将调试体系分为三部分，并规定了三者之间的通信接口。三部分由低到高分别是Java 虚拟机工具接口（JVMTI），Java 调试协议（JDWP）以及 Java 调试接口（JDI），三者之间的关系如下图所示

​	![](https://pdai.tech/images/jvm/java-class-enhancer-6.png)

而实现jvm attach api 的就是利用了 jvmti （JVM TOOL INTERFACE，JVM工具接口）的一部分能力，通过JVMTI，可以实现对JVM的多种操作，它通过接口注册各种事件勾子，在JVM事件触发时，同时触发预定义的勾子，以实现对各个JVM事件的响应，事件包括类文件加载、异常产生与捕获、线程启动和结束、进入和退出临界区、成员变量修改、GC开始和结束、方法调用进入和退出、临界区竞争与等待、VM启动与退出等等。

而Agent就是JVMTI的一种实现，Agent有两种启动方式，一是随Java进程启动而启动，经常见到的java -agentlib就是这种方式；二是运行时载入，通过attach API，将模块（jar包）动态地Attach到指定进程id的Java进程内。

### agent attach api 使用场景

至此，字节码增强技术的可使用范围就不再局限于JVM加载类前了。通过上述几个类库，我们可以在运行时对JVM中的类进行修改并重载了。通过这种手段，可以做的事情就变得很多了：

- 热部署：不部署服务而对线上服务做修改，可以做打点、增加日志等操作。
- Mock：测试时候对某些服务做Mock。
- 性能诊断工具：比如bTrace就是利用Instrument，实现无侵入地跟踪一个正在运行的JVM，监控到类和方法级别的状态信息。

##### JVM类加载机制说下

类加载主要是查找并且加载类的二进制字节码文件放到jvm中，供后续使用。jvm加载类的时候主要做了三件事

- 通过一个类的全限定名来获取其定义的二进制字节流。
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
- 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。

![](https://pdai.tech/images/jvm/java_jvm_classload_3.png)

- `启动类加载器`: Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载)。启动类加载器是无法被Java程序直接引用的。
- `扩展类加载器`: Extension ClassLoader，该加载器由`sun.misc.Launcher$ExtClassLoader`实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。
- `应用程序类加载器`: Application ClassLoader，该类加载器由`sun.misc.Launcher$AppClassLoader`来实现，它负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

##### JVM类加载机制的原则

- `全盘负责`，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入
- `父类委托`，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类
- `缓存机制`，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效
- `双亲委派机制`, 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。

**双亲委派机制过程？**

1. 当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。
2. 当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。
3. 如果BootStrapClassLoader加载失败(例如在$JAVA_HOME/jre/lib里未查找到该class)，会使用ExtClassLoader来尝试加载；
4. 若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。



##### JVM内存结构

![](https://pdai.tech/images/jvm/jvm/007S8ZIlly1gg9kuge8ovj32150tt7cd.jpg)

JMM是内存模型，指的是Java搞的一个规范，为了解决java如何分配使用内存，以及和外部交互的一套规范，内存结构是指在hotspot实现下，java的内促结构是什么样的。

###### 程序计数器

用来存储程序代码走到哪一行了，寄存器存储了 下一行要执行指令的地址。线程私有。

###### 虚拟机栈

java保存了方法的局部变量、部分结果，并且参与方法调用与返回，**栈不存在垃圾回收问题** 线程私有，对应着一次次 Java 方法调用，是线程私有的，生命周期和线程一致。

###### 本地方法栈

存放了很多本地方法，非java方法，方便java调用外界方法，比如分配内存，与操作系统交互。线程私有。在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一

###### 堆内存

Java 堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。

为了进行高效的垃圾回收，虚拟机把堆内存**逻辑上**划分成三块区域（分代的唯一理由就是优化 GC 性能）：

- 新生带（年轻代）：新对象和没达到一定年龄的对象都在新生代
- 老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大
- 元空间（JDK1.8 之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存

![](https://pdai.tech/images/jvm/jvm/00831rSTly1gdbr7ek6pfj30ci0560t4.jpg)

Java 虚拟机规范规定，Java 堆可以是处于物理上不连续的内存空间中，只要逻辑上是连续的即可，像磁盘空间一样。实现时，既可以是固定大小，也可以是可扩展的，主流虚拟机都是可扩展的（通过 `-Xmx` 和 `-Xms` 控制），如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 `OutOfMemoryError` 异常。

##### 什么是 TLAB （Thread Local Allocation Buffer）?

- 从内存模型而不是垃圾回收的角度，对 Eden 区域继续进行划分，JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内
- 多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为**快速分配策略**
- OpenJDK 衍生出来的 JVM 大都提供了 TLAB 设计

##### 为什么要有 TLAB ?

- 堆区是线程共享的，任何线程都可以访问到堆区中的共享数据
- 由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的
- 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度

##### 方法区是什么 ？

- 方法区（Method Area）与 Java 堆一样，是所有线程共享的内存区域。
- 虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。
- 运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本/字段/方法/接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 `String.intern()`方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出 `OutOfMemoryErro`r 异常。
- 方法区的大小和堆空间一样，可以选择固定大小也可选择可扩展，方法区的大小决定了系统可以放多少个类，如果系统类太多，导致方法区溢出，虚拟机同样会抛出内存溢出错误
- JVM 关闭后方法区即被释放

##### 方法区和元空间 区别？

- **方法区（method area）\**只是 \*\*JVM 规范\*\*中定义的一个\**概念**，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而**永久代（PermGen）\**是 \*\*Hotspot\*\* 虚拟机特有的概念， Java8 的时候又被\**元空间**取代了，永久代和元空间都可以理解为方法区的落地实现。
- 永久代物理是堆的一部分，和新生代，老年代地址是连续的（受垃圾回收器管理），而元空间存在于本地内存（我们常说的堆外内存，不受垃圾回收器管理），这样就不受 JVM 限制了，也比较难发生OOM（都会有溢出异常）
- Java7 中我们通过`-XX:PermSize` 和 `-xx:MaxPermSize` 来设置永久代参数，Java8 之后，随着永久代的取消，这些参数也就随之失效了，改为通过`-XX:MetaspaceSize` 和 `-XX:MaxMetaspaceSize` 用来设置元空间参数
- 存储内容不同，元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中
- 如果方法区域中的内存不能用于满足分配请求，则 Java 虚拟机抛出 `OutOfMemoryError`
- JVM 规范说方法区在逻辑上是堆的一部分，但目前实际上是与 Java 堆分开的（Non-Heap）

所以对于方法区，Java8 之后的变化：

- 移除了永久代（PermGen），替换为元空间（Metaspace）；
- 永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；
- 永久代中的 interned Strings 和 class static variables 转移到了 Java heap；
- 永久代参数 （PermSize MaxPermSize） -> 元空间参数（MetaspaceSize MaxMetaspaceSize）

HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收

判定一个类型是否属于“不再被使用的类”，需要同时满足三个条件：

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例
- 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常很难达成
- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

Java 虚拟机被允许堆满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot 虚拟机提供了 `-Xnoclassgc` 参数进行控制，还可以使用 `-verbose:class` 以及 `-XX:+TraceClassLoading` 、`-XX:+TraceClassUnLoading` 查看类加载和卸载信息。

在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。

##### JAVA垃圾回收算法有几种

###### 垃圾回收算法

1. 引用计数法：给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。引用计数法存在问题：两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。也有解决方法，可通过 Recycler 算法解决。

2. 可达性分析算法：通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。

   ![](https://pdai.tech/images/pics/0635cbe8.png)

   Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容:

   - 虚拟机栈中引用的对象
   - 本地方法栈中引用的对象
   - 方法区中类静态属性引用的对象
   - 方法区中的常量引用的对象

##### finalize方法是什么？

finalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。

当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法。

##### 引用类型分几种？

- 强引用：被强引用关联的对象不会被回收。使用 new 一个新对象的方式来创建强引用。
- 软引用：被软引用关联的对象只有在内存不够的情况下才会被回收。
- 使用 SoftReference 类来创建软引用。
- 弱引用：被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。
- 虚引用：又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。

##### 垃圾回收算法有几种？

1. 标记清除：缺点：标记和清除效率都不高，还容易造成内存碎片
2. 标记，整理
3. 复制算法：将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。缺点：每次只能使用一半内存

​		现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。

HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。

4. 分代收集算法:  现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。

   一般将堆分为新生代和老年代。

   - 新生代使用: 复制算法
   - 老年代使用: 标记 - 清除 或者 标记 - 整理 算法

##### 垃圾收集器有哪几种？

![](https://pdai.tech/images/pics/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg)

以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。

- 单线程与多线程: 单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；
- 串行与并行: 串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并形指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。

###### Serial收集器

![](https://pdai.tech/images/pics/22fda4ae-4dd5-489d-ab10-9ebfdad22ae0.jpg)

单线程收集器，client端默认收集器

###### ParNew 收集器

![](https://pdai.tech/images/pics/81538cd5-1bcf-4e31-86e5-e198df1e013b.jpg)

它是 Serial 收集器的多线程版本。

是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。

默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。

##### Parallel Scavenge 收集器

与 ParNew 一样是多线程收集器。

特点：1、尽可能缩短垃圾收集的时候用户线程的停顿时间，该收集器目标是达到一个可控制的吞吐量，成为吞吐量优先收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。

缩短停顿时间是以牺牲吞吐量和新生代空间来换取的: 新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。

可以通过一个开关参数打开 GC 自适应的调节策略(GC Ergonomics)，就不需要手动指定新生代的大小(-Xmn)、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。



##### Serial Old 收集器

![](https://pdai.tech/images/pics/08f32fd3-f736-4a67-81ca-295b2a7972f2.jpg)

是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途:

- 在 JDK 1.5 以及之前版本(Parallel Old 诞生以前)中与 Parallel Scavenge 收集器搭配使用。
- 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

##### Parallel Old 收集器

![](https://pdai.tech/images/pics/278fe431-af88-4a95-a895-9c3b80117de3.jpg)

是 Parallel Scavenge 收集器的老年代版本。

在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

##### CMS 收集器

![](https://pdai.tech/images/pics/62e77997-6957-4b68-8d12-bfd609bb2c68.jpg)

CMS(Concurrent Mark Sweep)，Mark Sweep 指的是标记 - 清除算法。

分为以下四个流程:

- 初始标记: 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。
- 并发标记: 进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。
- 重新标记: 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
- 并发清除: 不需要停顿。

在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。

具有以下缺点:

- 吞吐量低: 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。
- 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。
- 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。

##### 垃圾回收过程可以简单介绍下？

###### Minor GC、Major GC、Full GC

JVM 在进行 GC 时，并非每次都对堆内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。

针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full GC）

- 部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为： 
  - 新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集
  - 老年代收集（Major GC/Old GC）：只是老年代的垃圾收集 
    - 目前，只有 CMS GC 会有单独收集老年代的行为
    - 很多时候 Major GC 会和 Full GC 混合使用，需要具体分辨是老年代回收还是整堆回收
  - 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集 
    - 目前只有 G1 GC 会有这种行为
- 整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾

##### 内存分配策略可以说下？ 

1. 对象优先分配在eden区，对象优先进入eden区，不够发起 minor gc
2. 大对象直接进老年代，太大对象直接分配进 老年代
3. 长期存活对象直接进老年代   长期在Survivor对象中，每次minor gc年龄+1，超过一定阈值直接进 老年代
4. 动态对象年龄判定  Survivor 中相同年龄  对象总大小 大于空间一半  直接晋升老年代
5. 空间分配担保 ，指的是，young gc之前会判断  老年代大小，如果整个年轻代对象大小之和都小于老年代，会直接进行young gc，否则会判断系统是否允许 分配担保，如果不允许则直接 fgc，如果允许则再次判断 老年代剩余空间大小是否大于 历代平均晋升到老年代的对象大小，如果大于则进行young gc，否则直接full gc。

##### FullGc 触发的条件

ygc 一般触发条件比较简单，只要年轻代满了，就会触发ygc，fgc 触发条件会比较复杂。

1. 调用 System.gc()，但是实际上 系统不一定执行

2. 老年代空间不足，比如大对象进入 老年代，长时间存活的对象进入老年代

3. 空间分配担保失败

4. Jdk 1.7 以及之前，方法区 hotspot是用永久代实现的，永久代里存放了 各种class 文件，方法等，如果反射过多，加载的字节码过多但是未卸载，也会触发fgc。

5. Concurrent Mode Failure 执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足(可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足)，便会报 Concurrent Mode Failure 错误，并触发 Full GC。

##### 可以简单介绍下JAVA GC的过程



###### G1 垃圾收集器

g1垃圾收集器是 java 7 中引入的，他是一个分代的，增量的，并行与并发的标记-复制  垃圾回收器。他的设计目标主要是为了适应大内存，多核心cpu，并且为了进一步降低 暂停时间，同时需要兼顾良好的吞吐量。

g1和cms主要有以下区别

1. g1回收器是compacting的，回收的空间是连续的，当然cms通过加参数也可以大概上实现空间连续的效果
2. G1 回收器和cms回收器 内存模型是不同的，g1是把 内存分成了多个大小固定的region，每个region既可以是老年代也可以是年轻代，而内存回收是以region为单位进行回收的。
3. g1还提供了一个软实时的特性，就是可以控制gc时间在 指定的时间之内，这个主要是归功于 g1内存模型，可以尽量的把时间都控制在指定时间范围之内，但是还是会有超过的，基本可以控制90%以上都在范围。

##### G1内存模型简单说下？

###### region

G1采用了分区的思路，主要就是把内存分成了多个大小一致的region，同时也不要求对象的存储一定是物理连续的，只需要是逻辑连续的就好，默认分了2048个分区，大小可以通过参数指定，默认是2的倍数  1mb ~ 32mb。每个region既可以是老年代也可以是年轻代，可以转换的，不固定的。

###### 卡片 card

每个分区里面又会分为若干个大小为512byte的卡片，card。所有分区的卡片会记录在全局的卡片表，Global Card Table。分配的对象会占用物理上连续的若干个卡片，当查找对分区内对象的引用时便可通过记录卡片来查找该引用对象(见RSet)。每次对内存的回收，都是对指定分区的卡片进行处理。

###### 堆 heap

G1同样可以通过-Xms/-Xmx来指定堆空间大小。当发生年轻代收集或混合收集时，通过计算GC与应用的耗费时间比，自动调整堆空间大小。如果GC频率太高，则通过增加堆尺寸，来减少GC频率，相应地GC占用的时间也随之降低；目标参数-XX:GCTimeRatio即为GC与应用的耗费时间比，G1默认为9，而CMS默认为99，因为CMS的设计原则是耗费在GC上的时间尽可能的少。另外，当空间不足，如对象空间分配或转移失败时，G1会首先尝试增加堆空间，如果扩容失败，则发起担保的Full GC。Full GC后，堆尺寸计算结果也会调整堆空间。

###### g1的分代模型

g1虽然把内存按照region分配，但是g1其实在逻辑上还是保留了 年轻代，老年代的。只不过对比cms 老年代和年轻代的，g1的老年代和年轻代都是可以动态扩容的，主要目的还是为了指定的gc时间服务的，当然 g1也可以指定固定大小的年轻代和老年代，这样 g1的目标暂停时间参数则失去了意义。

###### 巨型分区Humongous Region

巨型分区指的是，创建的对象超过了 region大小的一半或者以上，巨型对象一般直接在老年代分配，占用的空间叫做巨型分区，g1有个优化，这种巨型对象一旦发现无引用可回收 则可以直接在young gc的时候跟年轻代直接回收，无需等到老年代回收。巨型分区的开始第一个分区叫做 开始巨型分区，其他叫做连续巨型分区

###### 已记忆集合Remember Set (RSet)

以前的gc算法通过整堆扫描 来找到存活对象，g1中则是通过remember set机制。rset是在每个region中记录了 其他哪些card引用了本分区的对象，相当于一个 对象引用索引。当需要回收本分区的时候，那直接扫描rset即可知道哪些对象是存活的，不需要整个堆扫描了。

但是并不是所有的region都会有rset，一般老年代region会有。

######  Per Region Table (PRT)

RSet在内部使用Per Region Table(PRT)记录分区的引用情况。有些对象引用过多，rset会很大，g1还做了一些优化调整，比如精确的记录那个card引用，或者粗略的记录哪个region引用，或者更粗略的通过 一个比特位来记录。粗粒度的PRT只是记录了引用数量，需要通过整堆扫描才能找出所有引用，因此扫描速度也是最慢的。

######  收集集合 (CSet)

![](https://pdai.tech/images/java/java-jvm-gc-g1-4.jpeg)

收集集合(CSet)代表每次GC暂停时回收的一系列目标分区region。在任意一次收集暂停中，CSet所有分区都会被释放，内部存活的对象都会被转移到空闲分区中。因此无论是年轻代收集，还是混合收集，工作的机制都是一致的。

年轻代收集CSet只容纳年轻代分区，而混合收集会通过启发式算法，在老年代候选回收分区中，筛选出回收收益最高的分区添加到CSet中。

候选老年代分区的CSet准入条件，可以通过活跃度阈值-XX:G1MixedGCLiveThresholdPercent(默认85%)进行设置，从而拦截那些回收开销巨大的对象；同时，每次混合收集可以包含候选老年代分区，可根据CSet对堆的总大小占比设置数量上限。

由上述可知，G1的收集都是根据CSet进行操作的，年轻代收集与混合收集没有明显的不同，最大的区别在于两种收集的触发条件。

###### 年轻代收集集合 CSet of Young Collection

应用线程不断活动后，年轻代空间会被逐渐填满。当JVM分配对象到Eden区域失败(Eden区已满)时，便会触发一次STW式的年轻代收集。在年轻代收集中，Eden分区存活的对象将被拷贝到Survivor分区；原有Survivor分区存活的对象，会继续放在新的survivor分区或者老年代分区。而原有的年轻代分区将被整体回收掉。这里的晋升依旧要判断 大小，年龄（默认15）等参数，才会晋升到老年代。

###### 混合收集集合 CSet of Mixed Collection

年轻代收集不断活动后，老年代的空间也会被逐渐填充。当老年代占用空间超过整堆比默认45%时，G1就会启动一次混合垃圾收集周期。为了满足暂停目标，G1会分多次将目标的cset进行收集，因此G1可能会产生连续多次的混合收集。

为了确定包含到年轻代收集集合CSet的老年代分区，G1会通过一系列算法计算出符合规则的老年代region，收益最大。

##### G1标记算法简单说下

G1 CMS都使用了三色标记法 ，分为黑白灰三种颜色。白色表示未标记，灰色表示自身被标记，但是引用对象未被标记，黑色表示自身与引用对象都已经被标记。白色对象是需要被清除的对象。

GC开始的时候，会把所有GCROOTS的对象压入栈中，此时所有对象均是白色对象，当遍历gcroots对象后找到所有的对象，这些可以被找到的对象都会被标记为灰色。然后继续标记的时候会把灰色对象继续遍历，遍历灰色对象的引用对象，当所有子对象被遍历完以后此对象会被标记为黑色，此时灰色对象消失，黑色对象是存活对象，白色对象是垃圾。

![](https://pdai.tech/images/java/java-jvm-gc-g1-5.png)

但是在并发标记的时候，引用关系有一定概率发生改变会导致漏标

比如 黑色指向灰色，灰色指向白色。当对象被标记为灰色，但是下面白色还没来的急扫描的时候

1. 灰色对象和白色对象断开连接
2. 黑色对象再指向断开的白色对象

当着2个步骤发生的时候就会导致 GC漏标，解决办法就是 两个条件 随便打破一个条件就可以了。

- **记录灰指向白的消失** SATB snapshot at the beginning：关注引用的删除，当灰–>白消失时，要把这个 引用 推到GC的堆栈，保证白还能被GC扫描到。G1采用该方法。（第一个条件）

- **跟踪黑指向白的增加** incremental update：增量更新，关注引用的增加，把黑色重新标记为灰色，下次重新扫描属性。CMS采用该方法。（第二个条件）

###### **为什么G1采用SATB而不用incremental update**？

因为采用incremental update把黑色重新标记为灰色后，之前扫描过的还要再扫描一遍，效率太低。G1有RSet与SATB相配合。Card Table里记录了RSet，RSet里记录了其他对象指向自己的引用，这样就不需要再扫描其他区域，只要扫描RSet就可以了。

也就是说 灰色–>白色 引用消失时，如果没有 黑色–>白色，引用会被push到堆栈，下次扫描时拿到这个引用，由于有RSet的存在，不需要扫描整个堆去查找指向白色的引用，效率比较高。SATB配合RSet浑然天成。



##### G1垃圾收集活动流程

![](https://pdai.tech/images/java/java-jvm-gc-g1-7.jpeg)

并发优化线程(Concurrence Refinement Threads)，只专注扫描日志缓冲区记录的卡片来维护更新RSet。

1、young gc   ，主要就是把 eden和survior区的对象复制到一个新的 survior，这个过程一般会找一个连续的内存复制，所以达到了减少内存碎片的目的。

2、并发标记周期（Concurrent Marking Cycle）是G1中非常重要的阶段，这个阶段将会为混合收集周期识别垃圾最多的老年代分区。整个周期完成根标记、识别所有(可能)存活对象，并计算每个分区的活跃度，从而确定GC效率等级（收集哪个region性价比最高）

当达到阈值(老年代占整堆比，默认45%)时，便会触发并发标记周期。整个并发标记周期将由初始标记(Initial Mark)、根分区扫描(Root Region Scanning)、并发标记(Concurrent Marking)、重新标记(Remark)、清除(Cleanup)几个阶段组成。其中，初始标记(随年轻代收集一起活动)、重新标记、清除是STW的，而并发标记如果来不及标记存活对象，则可能在并发标记过程中，G1又触发了几次年轻代收集。

2.1 初始标记阶段: STW

- 标记从根节点直接可达的对象。这个阶段是STW的,并且会触发一次年轻代GC(其实是利用了一次ygc 的 stw)

2.2 根区域扫描(Root Region Scanning): 

- G1 GC扫描Survivor区直接可达的老年代区域对象,并标记被引用的对象。这一过程必须在young GC之前完成(YoungGC时,会动Survivor区,所以这一过程必须在young GC之前完成)

2.3 并发标记(Concurrent Marking):

- 在整个堆中进行并发标记(和应用程序并发执行),此过程可能被young GC中断。在并发标记阶段,若发现区域对象中的所有对象都是垃圾,那这个区域会被立即回收。同时,并发标记过程中,会计算每个区域的对象活性**(区域中**存活对象的比例)。

2.4 再次标记(Remark): STW

- 由于应用程序持续进行,需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法:snapshot一at一the一beginning (SATB).

2.5 独占清理(cleanup,STW):

- 计算各个区域的存活对象和GC回收比例,并进行排序,识别可以混合回收的区域。为下阶段做铺垫。是STW的。(这个阶段并不会实际上去做垃圾的收集)

3、年轻代收集/混合收集周期

并发标记周期结束后，G1并不会马上开始一次混合收集，而是让应用线程先运行一段时间，等待触发一次年轻代收集。在这次STW中，G1将计算出下次混合收集的cset。接着再次让应用线程运行，当接下来的几次年轻代收集时，将会有老年代分区加入到CSet中，即触发混合收集，这些连续多次的混合收集称为混合收集周期(Mixed Collection Cycle)。

单次的混合收集与年轻代收集并无二致。根据暂停目标，老年代的分区可能不能一次暂停收集中被处理完，G1会发起连续多次的混合收集，称为混合收集周期(Mixed Collection Cycle)，



####  转移失败的担保机制 Full GC，G1依旧存在FGC

转移失败(Evacuation Failure)是指当G1无法在堆空间中申请新的分区时，G1便会触发担保机制，执行一次STW式的、单线程的Full GC。Full GC会对整堆做标记清除和压缩，最后将只包含纯粹的存活对象。参数-XX:G1ReservePercent(默认10%)可以保留空间，来应对晋升模式下的异常情况，最大占用整堆50%，更大也无意义。

G1在以下场景中会触发Full GC，条件：

- 从年轻代分区拷贝存活对象时，无法找到可用的空闲分区
- 从老年代分区转移存活对象时，无法找到可用的空闲分区
- 分配巨型对象时在老年代无法找到足够的连续分区

由于G1的应用场合往往堆内存都比较大，所以Full GC的收集代价非常昂贵，应该避免Full GC的发生。



###### ZGC简单介绍下

ZGC是JDK 11中推出的一款低延迟垃圾回收器, 是JDK 11+ 最为重要的更新之一，适用于**大内存低延迟**服务的内存管理和回收。承诺GC 时间小于10ms。

首先ZGC 跟G1 在结构原理的有类似的地方，

1、都是按照region分割堆内存，但是ZGC把region固定大小改成了3类，小中大，小的2m，中的32m，大型不固定可以动态分配，但是必须是2的倍数。

2、ZGC 和 G1一样都采用 标记 复制算法，以及 并发标记的三色算法

但是看G1整体的垃圾收集流程，可以发现

![](https://pdai.tech/images/java/jvm/java-jvm-zgc-1.png)

G1 消耗最大的地方在于 复制的时候 是stw的，整体耗时会比较高。而ZGC做到了复制对象的时候 是 并发复制的。ZGC并发复制主要是使用了两个技术，读屏障 和  染色指针。

染色指针：首先ZGC只支持64位系统，ZGC把64位对象指针的 42位到45位占用 用于存储元数据，分为 remapped  m0 m1 三种。三种只有一个位可以是1。ZGC使用这3位来存储判断一个对象是否是垃圾 或者存活对象。同时 参考以前的垃圾回收器，serial 是把对象的GC信息写在对象头上，G1 是把信息写在了堆中的一个单独结构中，所以这2个都是需要读堆内存的，而ZGC 则是通过染色指针把对象GC信息写在了 对象的引用指针上，这样就大大加速了对象GC信息的读取与判断。

读屏障：读屏障主要是 在并发标记阶段和 ZGC的并发复制阶段，在读对象的时候 添加执行一段代码，让读取对象之前 可以判断对象的GC状态来 修正 对象引用的指针 以及将旧对象引用转发到新对象上去，可以保障 并发复制阶段 可以并发 执行。

ZGC整体流程如下图：![](https://pdai.tech/images/java/jvm/java-jvm-zgc-2.png)

###### 初始标记

STW的，根据gcroots 使用三色标记算法，只标记GCROOTs的直接子对象，耗时很短，因为GCRoots 大小一般都不会大。

###### 并发标记/对象重定位

并发的标记，使用三色标记法标记 GCroots 子对象 以及 子对象的子对象，以及 在上一次 GC过程后留下的指针不对问题，会修正旧指针 指向新的指针

###### 再次标记

STW的，主要解决三色标记的漏标问题

##### 并发转移准备

主要目的就是分析出那些region对象不需要动，哪些需要转移，如何转移，转移到哪里。

###### 初始转移

STW，主要把GCRoots关联的子对象，复制到目标region中，只复制一层。

###### 并发转移

并发转移，就会把 GCroots的子对象的子对象全复制到目标region，再这个过程中，会建立 一张转发表，如果在并发复制的过程中，发现有业务程序 读取了 旧的对象，那么会从转发表中找到新对象地址，读取新的对象地址。等待下次GC 并发标记阶段，则会把旧的引用删除，修正为新的引用，转发表数据也会一起删除。



##### CMS GC流程

CMS垃圾回收器的垃圾收集分为四步：

- 初始标记（CMS initial mark）：单线程运行，需要Stop The World，标记GC Roots能直达的对象。
- 并发标记（（CMS concurrent mark）：无停顿，和用户线程同时运行，从GC Roots直达对象开始遍历整个对象图。
- 重新标记（CMS remark）：多线程运行，需要Stop The World，标记并发标记阶段产生对象。
- 并发清除（CMS concurrent sweep）：无停顿，和用户线程同时运行，清理掉标记阶段标记的死亡的对象。

##### CMS垃圾回收器存在的问题

1. 并发执行的时候会占用一部分系统线程，系统资源
2. 浮动垃圾无法清理，就是在并发清理阶段，用户线程又产生了新的对象，这个只要在后续GC里处理
3. 在GC的时候，遇到对象分配 如果预留空间不够 则会触发 Concurrent Mode Failure，然后触发一次单线程的FGC
4. 内存碎片，因为CMS使用的标记清除，会导致内存存在碎片，可以使用参数，每次CMS以后带一次内存碎片整理压缩。

##### 如何判断GC是否出问题了

GC主要考虑两个因素，一个是吞吐量，一个是延迟

延迟指的是，GC过程中最大的停顿时间，一定程度上可以接受 延迟变小，但是频次增加的。

吞吐量：吞吐量是指CPU时间分配在GC上使用和 用户线程使用的时间比，比如100分钟时间，GC总耗时1分钟，用户线程99分钟，那吞吐量就是99/100  99%。



##### GC原因常见场景

1. JVM起始内存和最大内存设置不一致，导致内存动态扩容的内存动荡，动态缩扩容会导致内存的重新分配，对象的复制等等操作，会极大的增加 gc时间，所以解决办法就是 -xms -xmx 设置的完全相同，一般为物理内存的1/4左右
2. 显示的使用System.gc()，虽然不会100%执行，但是一定程度上会导致不受控制的GC。 建议去除
3. 在动态加载类的代码项目中，一方面metaspace要设置的大一点，另外一方面要严格控制 类的加载， 否则容易导致 metaspace oom，因为清理 metaspace 类卸载耗时会比较大，所以过多的类卸载也会导致 cms耗时增加，从而产生雪崩效应。
4. 大对象要严格禁止，否则会导致 过早晋升，老年代被塞满，发生FGC，代码写的控制不好，还会导致oom。

##### GC调优常用参数/JVM参数

###### jvm参数

-xms  堆最小值

-xmx 堆最大值

-xmn 新生代大小

-XX:newRatio  新生代与老年代比例

-XX：PermSize  持久代大小

-XX:MaxPermSize  持久代最大大小

-XX:SurvivorRatio  新生代里  eden 和 survior 大小比例 默认 8:1

-XX:MaxTenuringThreshold  晋升老年代  年龄，默认15

-XX:+HeapDumpOnOutOfMemoryError：oom以后自动dump一份

GC垃圾收集器参数

-XX:+DisableExplicitGC：禁用system.gc

-XX:CMSFullGCsBeforeCompaction  cms多少次后触发一次 内存压缩

-XX:CMSInitiatingOccupancyFraction ：cms作为垃圾回收器，老年代剩余多少开始CMS收集

-XX:+PrintGCDetails ： 打印GC 详细信息

-XX:+PrintGCDateStamps：把时间戳也打印到GC信息中



##### JAVA自带的一些命令

jmap -dump:format=b file=<文件名XX.hprof> <pid>   dump内存

jsp  展示java进程

jstack  -l pid  dump线程堆栈，

jinfo  pid 查看系统配置信息，jvm的信息

jstat -gcutil pid 1000  查看pid下gc信息 1000次取样的统计信息

dmesg  如果发现自己的java进程悄无声息的消失了，几乎没有留下任何线索，那么dmesg一发，很有可能有你想要的。sudo dmesg|grep -i kill|less 去找关键字oom_killer。找到的结果类似如下

```bash
[6710782.021013] java invoked oom-killer: gfp_mask=0xd0, order=0, oom_adj=0, oom_scoe_adj=0
[6710782.070639] [<ffffffff81118898>] ? oom_kill_process+0x68/0x140 
[6710782.257588] Task in /LXC011175068174 killed as a result of limit of /LXC011175068174 
[6710784.698347] Memory cgroup out of memory: Kill process 215701 (java) score 854 or sacrifice child 
[6710784.707978] Killed process 215701, UID 679, (java) total-vm:11017300kB, anon-rss:7152432kB, file-rss:1232kB
```























