Mysql

##### 一条语句如何执行

首先mysql大致分为server端和存储引擎端，如果语句是查询语句，客户端将语句发送给mysql，先会通过连接器建立连接，连接器主要负责网络连接的管理以及权限控制，权限校验没问题以后，mysql会查找查询缓存，如果缓存里有数据，那会直接把数据缓存，如果没命中缓存则会通过mysql的分析器组件，分析器主要负责 sql的语法校验 分析，语法分析完以后mysql会走到优化器组件，优化器会决定具体用哪个索引，多表的时候具体哪个表连哪个表，等待优化器走完流程，则会调用存储引擎接口，存储引擎会根据接口调用查询指定的表，返回最终数据集给到 server端，server端拿到数据以后会更新下 查询缓存后，返回给客户端。

如果是更新语句的话，在查询语句的基础上会多两个重要的操作，一个是引擎端 会写redo log，并且设置为prepare 状态，紧接着server端会写 binlog，紧接着调用 引擎端接口，提交事务，将redo log 状态修改为commit。



##### 隔离级别如何保证

首先数据库有4种事务隔离级别，读未提交  读已提交  可重复读  串行化 。读未提交是指一个事务读到了另外一个事务还未提交的数据，串行化指的是，多个事务排队执行，只有一个事务执行完了，其他事务才可以继续执行。读已提交指的是，只有当前事务提交后，他所做的变更才能被看到。可重复度指的是 一个事务在执行过程中看的数据总是保持一致的。mysql默认是 可重复度 级别，而 oracle是 读已提交。

我以mysql默认的可重复度来解释下，mysql主要使用mvcc（多版本并发控制）和 read view 技术实现的事务隔离。mysql在启动事务的时候同时会创建一个read view视图，假设有多个事务更新同一条数据的话，那么在每个事务的视图中，这条数据的值是不同的，也就是说一条数据存在多个版本，这个是mysql里的mvcc，实现的方式主要是 mysql每次更改一条数据的时候同时会记录一个 undolog，表示这条数据从什么值改到了什么值，同时关联当前事务的id，这样 不同事务对应的一条记录的不同值通过undolog就可以推算出来，这样就做到了 同一个read view中 ，数据保证不变，从而保障了事务的隔离性。



##### 隔离级别MVCC快照具体实现（可重复读）

每个事务启动的时候会分配一个事务id trx_id，如果数据进行更新的话，trx_id则会写入到数据中，而trx_id是innodb申请的单调递增的。当事务启动时，如果一个数据版本是启动之前生成的 那就可读，而启动之后则不认可。mysql则会根据undolog trx_id 往前推出当前事务对应的数据值，这样mysql就利用了数据的多版本实现了mvvc快照。具体代码实现上，在启动事务的时候 同时会创建一个 当前已开启未提交的事务集合。同时把当前trx_id集合中 版本最小，版本最大的数据取出，称为高水位和低水位。当拿到一个数据的时候，取到关联的trx_id，

1. 如果当前trx_id在低水位以下，则说明事务已提交，可见。

2. 如果当前trx_id在高水位以上，则说明事务是在当前事务之后生成的不可预见

3. trx_id在 高低水位之间

   3.1 trx_id在集合中，说明事务未提交，不可见

   3.2 trx_id在不在集合中，说明事务已提交，可见。

但是会有特殊逻辑，可重复读中的更新数据使用的是当前读。比如A事务开启后，还未执行具体update语句，但是B事务立刻开启同时执行了更新语句并提交了事务，这时候A事务执行update语句的时候 就会强制读最新的已提交的数据然后再进行更新，这个叫做当前读。而在更新过以后，如果A再执行查询语句，因为update语句已经把当前事务id写入了此条数据，查询语句便会认为当前数据的版本是可读的，所以查询出来的数据 变已经是update更新后的数据了，即使此时事务还未提交。



读提交相对 可重复读的区别，每个语句执行之前都会重新生成 read view视图，而可重复读是事务启动的时候 创建一致性的read view视图。



##### 索引的原理

索引就是一种数据结构，mysql可以通过索引提高查询效率快速的查找到数据。具体实现针对innodb来说，mysql索引使用b+树实现，b+树其实是 平衡多叉树，比较适合 等值，顺序查询等。

聚簇索引：索引和数据全保存在一起，比如innodb的 id索引就是聚簇索引

非聚簇索引：索引和数据分开保存，innodb的普通索引都是非聚簇索引

联合索引：多个字段一起做索引，可以支持最左匹配

覆盖/复合索引：联合索引里的一种特殊形式，索引可以支持所有的数据获取

索引下推：a like xxx  b > yyy  索引(ab)，mysql会从索引层面 先找到 和a匹配的数据，然后再过滤掉 b>yyy的值的 数据，再进行回表，这个叫索引下推，非下推则是  找到匹配a的数据，然后回表拿到所有数据，在进行b字段的筛选。简单来说就是一种索引筛选数据的优化策略。

##### 慢查询优化

一般有些步骤，收到慢sql告警 

1、加个sql_no_cache  确认下是否真的慢查询

2、explain看执行计划，主要看 key 是否用到索引，rows 查询扫描的数据数量，extra里的 信息，看看是否符合预期

3、大小表连的话，小表驱动大表

4、复杂的慢sql需要关联业务代码一起看，是否需要拆分业务逻辑



##### 索引为什么不使用 hash表，不使用b树，不使用跳表

hash表一般适用等值查询，没法范围查询。

b树：每个节点不仅要常数据还要存储对应的硬盘指针，b+树存储的是索引数据和其他需要的节点指针，数据量要小于b树，这样同等内存就可以读取更多的节点数据，大大增加了查询效率

跳表：跳表问题类似b树，相同的跳表和b+树数据量，跳表层高更高导致需要多次读盘，查询效率要远低于B+树。



##### innodb mysiam区别

1. innodb支持事务，myisam不支持
2. innodb支持行/表数据锁，myisam只支持表锁
3. myisam索引和数据是存储在一起的，所以大数据量的查询，高频查询 myisam更友善
4. myisam多存储了 数据总条数，innodb需要从头到尾重新数

DDL DML DQL  DCL

dml：Data Manipulation Language  insert update delete数据

DDL：改表定义  Data Definition Language

DQL：查询语句 QUERY

DCL： grant 赋权 控制语句   Control 



##### 表锁

innodb 有三种锁，全局锁，表锁，行数据锁

ftwrl： flush table with read lock，，全局锁，全局锁大多数情况是用来 做数据库备份的，在这种情况下，所有更新语句，ddl，dml 语句会被禁止。

表锁：表锁分两种，一种是表锁，另外一种是 mdl（meta data lock)。lock tables t1 with read, t2 write ， 这样起线程就只可以对t1 read，t2写。 

mdl是只要访问一个锁都会加上，锁的是表的元数据，比如表字段。主要是为了保障读写的一致性（改数据结构和读数据的时候要一致）。需要对表做增删改查操作的时候加mdl读锁，需要改表结构的时候加mdl写锁，读锁是共享锁，写锁是排他锁，读写锁也互斥。

行数据锁：行锁就是同一条数据执行dml 操作的时候会加锁，行锁是需要才申请加，但是是事务结束才释放。基于这个原则那么一般最影响并发的 dml语句需要靠近 事务快结束的时候。行锁容易导致死锁等待，比如A事务 update id =1  然后update id =2 ，B事务update id = 2 然后再 update id = 1 ，两个错开执行的时候容易导致 死锁。

##### 行锁导致的死锁如何解决

1. 默认行锁会有50秒的超时时间，可以改短一点超时时间，效果有限

2.  关闭死锁检测，那会导致业务数据受损，具体要看业务数据重要程度做抉择。

3. 行锁的死锁检查是只有 block住的线程才会检测，假如100并发，那就是100*100次检测，很浪费性能，还会导致事务执行性能受损。

##### 怎么解决死锁检测导致的热点更新

一般两种解决方式

1. 关闭死锁检测
2. 限流排队，客户端层面，mysql server端也可以做
3. 逻辑拆行，一条数据逻辑上 拆成多条数据



##### binlog   redo log 区别

binlog 是在服务端层的，主要作用

1. 数据存档
2. 主从复制
3. 数据消费

redo log主要是在 引擎层，innodb引擎独有的日志，采用write ahead log wal技术，可以保障 数据库的crash-safe能力，保障数据库的崩溃可以恢复，binlog 无法保障是因为 binlog 无法感知哪些数据是落盘的，而redo log有checkpoint能力，可以知道checkpoint之前的全是落盘的数据。

理论上redo log单独就可以保障mysql的 crash-safe，但是binlog 其实还有其他作用。

redo log记录的是某个数据页 做了什么修改，所以redo log是需要先把磁盘数据读到内存中再进行修改的

binlog 有两种格式，statement 和 row格式，statement记录的是 sql语句 row格式记录的是 表修改的细节。

mixed：statement和row的混合形式，statement 会导致某些函数在 从库中错误，所以会使用row格式来记录，比如 now()之类的。



##### mysql更新数据的change buffer是什么

change buffer是mysql为了提高性能搞的一个机制。当更新数据的时候，mysql会把更新操作缓存到一块内存之中，这块内存叫做change buffer。当有查询请求需要加载这个数据页的时候，mysql会把磁盘中数据加载进内存，同时和change buffer的更新操作做merge，或者mysql后有定时线程 也会把数据读进内存和change buffer做merge。这个就是change buffer，适用于写多读少的场景。



##### 唯一索引和普通索引区别，怎么选

唯一索引是需要字段在数据库表中有唯一性，普通索引不需要。读的时候没太大区别，都是mysql把对应的数据的数据页加载到内存中，唯一索引是读到一条数据就返回了，普通索引是读到不是 指定数据才全部范围，整个过程大概率都是在内存中操作的。但是更新的时候会有区别，唯一/普通索引更新或者插入的事后如果目标数据在内存中，那直接在change buffer中修改数据，等待merge操作即可，唯一索引区别就是多判断下是否重复，但是当目标数据不在内存中的时候，唯一索引是必须要立刻把数据页读取到内存中，再进行判断的。而普通索引因为change buffer的merge机制 只需要在change buffer中记录操作即可。也就是说对于唯一索引，更新操作会导致触发change buffer 的merge 增加io次数，效率下降。所以尽量减少唯一索引的使用，可以使用普通索引尽量使用普通索引。



##### mysql索引会选错吗

会的，主要原因就是  索引的数据错误，mysql会采样收集 一个索引的区分度信息，表示这个索引的数据的区分度，散列程度。因为是采样就会有误差，当误差越来越大的时候，就会导致mysql选错索引。

解决办法

1. Force index
2. analyze table 让mysql 重新统计索引信息
3. 删除索引 增加新的索引



##### mysql主备同步是怎么做的

主库和备库之间保持了一个长连接，当主库写完binlog以后，会按备库要求的binlog 文件位置 把最新的binlog 同步给备库，备库收到主库同步的binlog以后会写一个中间日志文件，relay log，最后 备库会有另外一个线程读取 relay log日志，写到数据库中。



##### 主从同步延迟原因

1. 主库大量dml语句，从库 查询语句过多，导致cpu很高，无法快速同步binlog
2. 从库机器配置较差
3. 主从配置参数不同
4. 主库大事务 长事务
5. 从库备份操作，锁全局，导致无法同步
6. 本身设置了 延迟同步



##### 如何解决读写分离导致的 过期读问题

1. 强制读主库
2. select sleep 几秒
3. 重要数据 立刻需要查询展示的数据 可以强制读主库，不重要的查询允许查不到



##### 什么是幻读，幻读有什么问题

幻读是出现在可重复读隔离级别下 读取数据不一致的问题，核心原因就是 当前读，即一个事务两次当前读读到的不一致数据，主要就是针对的 新插入数据的情况。比如A事务 读 a =10的数据，B事务又插入了一条a=10的数据，在RR下，A事务两次读读到不同的数据就是幻读。幻读在RR下一定会遇到，但是可以解决，即加间隙锁。 假如 数据库里有 a=5,  a =15两条数据，当A事务 读a=10 加锁的时候，需要加间隙锁 即 (5,10]  5到10数据全部加锁，这个区间全部要加锁，不允许插入，这样 B事务插入的时候就会被block住。

间隙锁，锁的是数据之间间隙，两个相同的间隙锁之间并不冲突，间隙锁只和 insert行为冲突。 单条数据锁叫做行锁

间隙锁 英文叫 gap-lock  和 行锁 加起来叫做  next-key lock。 



##### 分库分表

https://github.com/moxi624/LearningNotes/blob/master/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E6%89%AB%E7%9B%B2%E5%AD%A6%E4%B9%A0/11_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E9%9D%A2%E8%AF%95%E8%BF%9E%E7%8E%AF%E7%82%AE/README.md



Sharding-JDBC

https://juejin.cn/post/6894046209552416782





































