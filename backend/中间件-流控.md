##### 限流，降级，熔断 分别有什么区别

限流一般是调用本系统流量过高，需要限制

熔断指的是，自身调用外部服务的时候，外部服务不可用，需要熔断，不再调用，或者返回默认值。

降级 强调的是 从业务层面，为了保障核心业务流程的可用性，选择性的降低一些其他功能的可用性

##### 漏桶算法 & 令牌桶算法 区别

漏桶和令牌桶算法都是 限流常见的算法，主要区别在于，漏桶是进来一个，出去一个，令牌桶是 起始有固定数额，允许某一个很短的时间大量的调用，对于系统会有一个缓冲的作用

##### 固定时间窗口，滑动时间窗口 区别？

固定时间窗口 ，就是从某个时刻开始，固定一段时间，形成的时间差就叫做固定时间窗口

滑动时间窗口，就是规定，最小窗口是某个时间，比如100ms，那任意时刻 往前可以推 2个时间窗口，或者5个时间窗口。这个就叫滑动时间窗口

##### Hystrix 原理简介下

Hystrix是一个中间件，主要目的是隔绝微服务之间的服务故障。

Hystrix 的资源模型设计上采用了命令模式，将对外部资源的调用和 fallback 逻辑封装成一个命令对象（`HystrixCommand` / `HystrixObservableCommand`），其底层的执行是基于 RxJava 实现的。每个 Command 创建时都要指定 commandKey 和 groupKey（用于区分资源）以及对应的隔离策略（线程池隔离 or 信号量隔离）。线程池隔离模式下需要配置线程池对应的参数（线程池名称、容量、排队超时等），然后 Command 就会在指定的线程池按照指定的容错策略执行；信号量隔离模式下需要配置最大并发数，执行 Command 时 Hystrix 就会限制其并发调用。

Sentinel 的设计则更为简单。相比 Hystrix Command 强依赖隔离规则，Sentinel 的资源定义与规则配置的耦合度更低。Hystrix 的 Command 强依赖于隔离规则配置的原因是隔离规则会直接影响 Command 的执行。在执行的时候 Hystrix 会解析 Command 的隔离规则来创建 RxJava Scheduler 并在其上调度执行，若是线程池模式则 Scheduler 底层的线程池为配置的线程池，若是信号量模式则简单包装成当前线程执行的 Scheduler。而 Sentinel 并不指定执行模型，也不关注应用是如何执行的。Sentinel 的原则非常简单：根据对应资源配置的规则来为资源执行相应的限流/降级/负载保护策略。在 Sentinel 中资源定义和规则配置是分离的。用户先通过 Sentinel API 给对应的业务逻辑定义资源（埋点），然后可以在需要的时候配置规则。埋点方式有两种：

- try-catch 方式（通过 `SphU.entry(...)`），用户在 catch 块中执行异常处理 / fallback
- if-else 方式（通过 `SphO.entry(...)`），当返回 false 时执行异常处理 / fallback

Sentinel 还支持基于注解的资源定义方式，可以通过 `@SentinelResource` 注解参数指定异常处理函数和 fallback 函数。



##### Sentinel 原理简介下

![](https://sentinelguard.io/docs/zh-cn/img/sentinel-slot-chain-architecture.png)

简单来说就是sentinel 你要对一个东西进行限流或者监控，他需要先定义一个资源，这个资源就代表你要保护的目标对象，那在创建这个资源的时候，其实又叫 一个entry，同时会创建一系列的slot，插槽的意思。紧接着这些slot会形成链式结构，也就是当你执行 你目标方法之前，sentinel会调用 api，这个api就会同时通过责任链的方式，链式的调用一些列的slot代码，这里包括 记录调用链的slot，记录监控数据的slot，鉴权的slot，限流的slot，熔断的slot，等等，全部调用完，没有任何问题的时候，就会调用业务代码，否则直接抛异常。

##### Hystrix 和 Sentinel 区别是什么 ？

最后用表格来进行对比总结：

|                | Sentinel                                       | Hystrix                       |
| -------------- | ---------------------------------------------- | ----------------------------- |
| 隔离策略       | 信号量隔离                                     | 线程池隔离/信号量隔离         |
| 熔断降级策略   | 基于慢调用比例或异常比例                       | 基于失败比率                  |
| 实时指标实现   | 滑动窗口                                       | 滑动窗口（基于 RxJava）       |
| 规则配置       | 支持多种数据源                                 | 支持多种数据源                |
| 扩展性         | 多个扩展点                                     | 插件的形式                    |
| 基于注解的支持 | 支持                                           | 支持                          |
| 限流           | 基于 QPS，支持基于调用关系的限流               | 有限的支持                    |
| 流量整形       | 支持慢启动、匀速排队模式                       | 不支持                        |
| 系统自适应保护 | 支持                                           | 不支持                        |
| 控制台         | 开箱即用，可配置规则、查看秒级监控、机器发现等 | 不完善                        |
| 常见框架的适配 | Servlet、Spring Cloud、Dubbo、gRPC 等          | Servlet、Spring Cloud Netflix |

核心区别在于

1. 服务隔离策略不同，sentinel基于信号量去隔离的，hystrix 是基于信号量和 线程池两种方式可选的隔离
2. 熔断策略不同，sentinel 可以设置基于rt或者异常比例，hystrix是基于 失败比例
3. 限流方式不同，sentinel基于qps、调用方、热点参数都可以限流，hystrix 基于 qps
4. 流量整形，sentinel可以做到，流量的排队，慢启动。原生hystrix是不支持 流量排队的。
5. 分布式限流，sentinel提供了分布式限流，hystrix没有
6. dashbord ，sentinel好看点。
7. sentinel 代码写起来真的简单点，简洁。



##### sentinel 如何计算流量

sentinel里使用了循环数组，或者说就是2个固定长度的数据来实现了流量统计。sentinel有2个数量统计的数据。一个是把1秒分成了2个500ms的窗口，还有一个是把60秒分成了60个窗口，其实原理是一样的。我以1秒2个窗口来举例。sentinel把1秒分成2个窗口，假设是从0ms开始计时，那2个窗口起止时间分别是 0到500ms 和 500ms到1000ms。假设在800ms的时候过来一个请求，sentinel会分三步

1. 第一步计算 800ms应该在的窗口区间，计算出来应该是在第二个窗口区间
2. 计算800ms这个窗口应该的起始时间，500ms
3. 这时候从 统计的数据 数据里，取第二个窗口区间，index = 1。然后分三种情况

- 取出来对象为空，说明此时并没有流量，那比较简单，直接new个对象出来然后直接把当前流量加进去。
- 取出来对象不为空，并且对象窗口起始的时间和 我计算出来的时间是相同的，说明是正确的窗口，直接加+1
- 取出来对象不为空，但是对象窗口时间和我计算出来的时间对不上，说明时间窗口过期了，所以直接把对象时间窗口所有统计数据全部抹除，然后+1

sentinel 就是通过这种方式把当前所有时间窗口慢慢滑动，并且得到计数的数据，然后把所有数据相加 除以 时间，那就是当前窗口的qps了，然后和目标qps对比，超过就限流，不超过就放行。

##### Hystrix 怎么计算滑动时间窗口统计的 ？

1.5 版本之前是通过环形数组来实现的滑动时间窗口，1.5 版本是通过RxJava来实现的。Hystrix 1.5 开始对实时指标统计的实现进行了重构，将指标统计数据结构抽象成了响应式流（reactive stream）的形式，方便消费者去利用指标信息。同时底层改造成了基于 RxJava 的事件驱动模式，在服务调用成功/失败/超时的时候发布相应的事件，通过一系列的变换和聚合最终得到实时的指标统计数据流，可以被熔断器或 Dashboard 消费。

##### 