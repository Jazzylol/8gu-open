##### TCP面试题

https://zhuanlan.zhihu.com/p/108822858

https://juejin.cn/post/6983639186146328607#heading-9



##### TCP和UDP的区别

1. TCP是面向连接的，UDP是无连接的，发送数据TCP需要先建立链接，UDP不需要
2. TCP提供的是安全可靠的服务，保障传输的数据不丢失，不重复。UDP只管发
3. TCP是点对点的，只有双方，UDP是可以一对多的，多对多的。
4. TCP因为要保障数据不重复，不丢失，传输效率要低于UDP
5. TCP面向字节流，UDP面向报文

##### TCP如何保障可靠性

1. 首先TCP链接的建立是三次握手，四次挥手，确保连接和断开的可靠性
2. TCP会保障数据传输的有状态，会记录哪些数据传输了，哪些没有传输，还会保障数据之间的顺序。
3. TCP还保障数据传输的可控制能力，有报文校验，ack应答，超时重传，流量控制，拥塞控制等能力

##### TCP三次握手

1. 服务端listen某个端口
2. 第一次客户端发送请求，SYN=1  seq = x，发送完毕，客户端进入 SYN_SEND状态
3. 服务端接受到客户端发送请求，SYN=1，ACK=1，seq = y，ACKnum = x+1，发送完毕后 服务端进入  SYN_RCVD状态
4. 客户端接收到服务端发送回来的请求，ACK=1，ACKnum=y+1，发送完毕后 客户端进入 ESTABLISHED 状态，服务端收到包后也进入ESTABLISHED 状态，连接建立

##### TCP四次挥手

1. 客户端发送结束请求，FIN=1，seq = u，发送完毕，客户端进入FIN_WAIT_1状态
2. 服务端接收到结束请求后，返回 ACK=1，acknum = u+1,  seq = v，发送完毕后服务端进入CLOSE_WAIT状态
3. 客户端收到包后 修改状态为  FIN_WAIT_2状态
4. 第三次挥手，等待一段时间后，服务端数据发送完毕，服务端准备关闭，发送数据包给客户端，第三次挥手，FIN=1,ACK=1，seq = w，ack = u+1，服务端进入 LAST_ACK状态,等待客户端的最后一次ack.
5. 客户端收到第三次挥手后，进入第四次挥手状态，ACK=1，seq = u+1，ack = w+1，客户端收到了来自服务端请求的链接关闭包，发送给服务端一个确认包以后，进入TIME_WAIT状态，等待了固定时间以后，客户端认为链接已经正常关闭，修改自身状态为CLOSED，服务端接收到 确认包以后，直接关闭连接修改状态为CLOSED

##### TCP挥手为什么需要四次

主要就是服务端接收到关闭连接请求的时候，可能存在一定数据并没有发送完成，所以要等待数据发送完成才可以响应关闭连接请求。

##### TCP挥手最后客户端的TIME_WAIT状态为什么需要等待一段时间

1. 保障最后客户端发送给服务端的ack可以发送出去
2. 保证即使客户端的ack重传的FIN报文能够到达

##### TCP超时重传机制

TCP重传机制分三种，超时重传，快速重传，带选择确认的重传(SACK重传) 

1. 超时重传，指的是 TCP超过一个数据包的RTT时间则直接重传。时间成为RTO，RTO一般设置略大于RTT，设置有个标准的公式。缺点是 1、需要等待一定时间才开始重传，增加了端到端的延迟，2、有时候因为网络原因，服务端发送了ack，但是客户端没收到依旧重传，加重了网络负担，不必要的重传增加了负载，浪费网络资源。

2. 快速重传，指的是TCP不以时间来判断重传，而是以服务端的ack来判断重传，假设客户端发送了1，2，3，4，5，6 份数据

   客户端发送seq =1 ，服务端发送ack =2

   客户端发送seq=2，服务端发送ack =3 

   客户端发送seq =3 ，服务端未接收到，

   客户端发送seq = 4，服务端接收到但是发送ack=3

   客户端发送seq = 5，服务端发送ack =3 

   客户端发送seq = 6，服务端发送ack = 3

   所以客户端收到了重复的3个ack =3 ，客户端会重传 seq =3的包，然后服务端确认 seq = 4，5，6都收到了，重传seq=3以后，服务端ack回7。

   缺点：服务端ack只向发送端告知收到的有序最大的报文段，但是具体哪个报文丢失了，客户端并不知道，重传多少包客户端也不知道。

3. SACK重传，有选择的重传指的是，在快速重传的基础上，ACK包会把服务端最近接收到的报文序列返回回去，写在TCP头部选项字段中，这样发送端就知道哪个序号的报文丢失了，选择性的重发。

4. DSACK重传是在SACK重传的基础上再加了 告诉发送端，自己哪些数据重复了，这样是帮助发送端判断是否发生了错误重传，包顺序错误等问题，这样方便发送端做 流控。

##### TCP的滑动窗口是什么意思

TCP滑动窗口主要是为了解决每次发送数据必须等待ack才能继续发送导致的效率低下问题。为了解决这个问题TCP引入了窗口的概念，他是操作系统开辟的一块缓存空间，表示无需等待ack 可以继续发送数据的最大值。

TCP头部有个字段叫 win，也就是16位窗口的大小，他表示告诉发送端 本端TCP缓冲区还是可以容纳多少字节的数据,这样对方就可以控制发送数据的速度,从而达到流控的目的。通俗的说就是发送ack的时候同时告诉发送端自己还有多少缓冲区空余空间，这个就是接收窗口的大小，也就是win。

TCP滑动窗口分为发送端滑动窗口 和 接收端滑动窗口

发送端滑动窗口分为四部分

1. 已发送已收到ack
2. 已发送未收到ack
3. 未发送，但是可以发送
4. 未发送，同时不可以发送

其中 已发送未收到ack和未发送但是可以发送 统称为 发送窗口。

接收方滑动窗口分为三部分

1. 已收到，并且ack
2. 未收到但是可以接收
3. 未收到同时不可以接收

未收到但是可以接收就是  接收窗口



##### TCP的流量控制

TCP提供了一种机制就是让发送端根据接收端的实际接收能力来控制自己发送的数量，这个就是流量控制。举例来说，假设接收端可以收400个字节，发送端第一次发了200个字节，接收端收到后把200个字节存储到缓冲区中，紧接着告诉ack告诉接收端自己还剩200个字节可以发送，发送端收到ack后又发送了200个字节，接收端收到新的200个字节后 放到缓冲区中，假如这一段时间接收端一直没处理缓冲区的数据，那么ack给发送端的就是 tcp win字段为0，表示我暂时没有空余空间可以发送了，这时候接收端就会暂停发送数据，起一个定时任务，每隔一段时间询问接收端 是否有空余空间，一直到接收端 win 字段大于0 才会再次发送。接收端则是一直等到数据处理有空余空间，才会告诉发送端 win大小。

流量控制主要是避免 发送端无脑发送导致的 网络资源浪费，网络拥塞等问题。



##### TCP拥塞控制

TCP拥塞控制主要是为了最大化利用网络资源 针对发送端的控制行为。TCP流量控制主要是针对 接收端的控制。 拥塞控制主要作用域TCP发送端，TCP发送端维护了一个拥塞窗口的变量，cwnd，congestion window，这个变量表示的含义就是 网络带宽上数据包的承载承担。TCP发送端的逻辑就是 只要网络没发送堵塞，那这个变量就会一直增大，一直增加网络包的传输，等到网络阻塞了，再迅速回调。

拥塞控制主要有几个阶段 算法

1. 慢启动
2. 拥塞避免
3. 拥塞发生
4. 快速回复

慢启动就是在tcp开始传输的时候 会慢慢的增加数据包的数量一直到一个阈值，当到达阈值以后就会进入到拥塞算法中，慢启动更像一个指数函数，避免算法则更像线性函数，当避免算法 cwnd触发拥塞以后，进入拥塞发生算法，拥塞发生算法会立刻重置cwnd ，迅速恢复到慢启动状态，其实也就是超时重传，但是如果连续收到3个相同重复的ack，那就会进入到快速回复算法，直接重传，不再等到超时重传。然后继续慢慢增加数据包的数量，直到再次出发拥塞状态。



##### TCP的SYN FLOOD攻击是怎么回事

SYN FLOOD攻击是一种典型的 服务拒绝攻击 DOS 攻击，Denial of Service ，主要原因就是 客户端通过伪造ip或者真实的大量ip在短时间内向服务端发送建立TCP连接的请求，服务端就会大量恢复SYN + ACK报文，但是又收不到回复，这种链接叫做半链接，半链接有队列，当半链接队列满了以后，服务端就无法再建立新的链接，导致正常请求会被拒绝。

解决办法基本就是 

1. SYNC COOKIE 简单来说就是 通过检测发送端的SYN包，包括源地址，端口等信息 计算出一个唯一key，然后不建立TCP半链接,直接回复ACK，当收到对方ACK以后才真正建立连接。
2. SYNC PROXY防火墙，在源地址和服务端之间建立一套新的服务器，这些服务器类似SYNC COOKIE处理方式，当真正收到ACK包以后再 构造新的包发送到真正的服务端 建立TCP连接。

##### TCP Nagle算法和延迟确认是什么意思

主要还是为了提高数据传输效率，假设发送端每次全部发送1字节的数据，不停的发送不停的等待ack，那效率是非常低的，而且TCP发送还要封包 再解包，效率很低。Nagle算法就是规定当前只允许存在一个 发送了但是未收到ACK的小包存在（小于MSS 最大报文长度），其他时间都要等待一起发送，TCP是希望尽量发大的数据包。但是也是有一些其他条件的，比如超过200ms会直接发，FIN报文也会直接发，设置了NO_DELAY 选项也会直接发。

延迟确认是指，接收端短时间内连续收到多个报文，可以统一发送ack，也就是收到一个报文后可以等待一段时间然后发送ack，这个时间linux默认是40ms，但是一样的也有例外情况，比如收到了乱序包，那就需要立刻ack，等待一定时间超时了也需要立刻ack，避免发送端以为丢包。

不管nagle算法和延迟确认，这两个主要还是为了提高TCP数据包发送效率，但是一般 不可以同时使用，会导致发送延迟，接受延迟累加，导致整体数据延迟更高。

##### TCP粘包和拆包是怎么回事

TCP是面向字节流的，传输的数据是没有任何边界的，TCP不会理解业务上数据的含义，他只是发送数据包而已，所以TCP会发生将多个包合并到一起发送，也会发生将大包拆成多个小包分别发送，这个就是 粘包和拆包。

UDP不会发生的原因是UDP的每个包都是有数据长度的，TCP是面向字节流的，当然UDP并不保证数据包一定送达，更适合流媒体 直播这种。

发生原因：

1. TCP要发送的数据小于数据发送缓冲区大小，则将多份数据合并到一起发送，称为粘包
2. 接收端存在问题没有立刻处理数据，导致多个数据都存放在接收缓冲区也会发送粘包
3. 发送端要发送的数据大于TCP数据缓冲区大小，则发生拆包 发送

解决方案：

1. 发送端将每个数据包 封装为固定大小
2. 在数据尾部添加特殊字符进行分割（FTP协议是这样处理的）
3. 将数据分为两部分，一部分是头部，一部分是内容体，其中头部大小固定，存储一个字段来表明 内容体大小（通过自定义协议来进行封包和拆包）

总结就是  TCP这个层面解决不了，TCP只负责发数据包而已，需要从应用层面去解决，在应用层将数据转成二进制之前 想办法解决，解包的时候再根据之前的协议来 反向解包。类似Netty里有几种解决方式的Decoder。



##### 三层网络模型 七层网络模型

##### HTTP HTTPS HTTP2 SPDY



